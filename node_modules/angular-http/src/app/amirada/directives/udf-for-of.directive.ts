import {
  Directive,
  Input,
  TemplateRef,
  ViewContainerRef,
  IterableDiffers,
  IterableDiffer,
  ViewRef,
  NgIterable,
  IterableDifferFactory,
  ChangeDetectorRef,
  DoCheck,
  TrackByFunction, Output, OnInit
} from '@angular/core';

import { UDFModel } from '../models/udf.model';
// import { DynCompLoaderService } from '../dyncomp.service';

@Directive({
  selector: '[pfFor]'
})
export class ForDirective implements OnInit, DoCheck {

  private _viewMap: Map<any, ViewRef> = new Map<any, ViewRef>();
  private _differ: IterableDiffer<any>;
  private _collection: NgIterable<any>;
  // private _context: PfTestDirectiveContect;
  private _trackByFn: TrackByFunction<any> = ((index, item) => {return item.id || index; });
  public model: UDFModel;

  @Input() set pfFor(model: UDFModel) {
    this.model = model;
  }
  @Input() set pfForOf(iterableModel: UDFModel){
    if (iterableModel && !this._differ) {
      this._collection = iterableModel;
      this._differ = this._differs.find(this._collection).create(this._changeDetector, this._trackByFn);
    }
  }

  @Input()
  set pfForTrackBy(fn: (index: number, item: any) => any) {
    if (typeof fn === 'function') {
      this._trackByFn = fn;
    } else {
      console.warn(`trackBy must be a function, but received ${JSON.stringify(fn)}.`);
    }
  }


  constructor(
    private templateRef: TemplateRef<PfTestDirectiveContext<any>>,
    private _viewContainerRef: ViewContainerRef,
    private _differs: IterableDiffers,
    private _changeDetector: ChangeDetectorRef,
    // private _loader: DynCompLoaderService
  ) {
    // debugger;
  }

  ngOnInit() {}

  ngDoCheck() {
    if (this._differ) {
      const changes = this._differ.diff(this._collection);
      if (changes) {
        changes.forEachAddedItem(change => {
          this._addItem(change.item, change.currentIndex);
          // this._create(change.item, change.currentIndex);
        });
        changes.forEachRemovedItem(change => {
          const view = this._viewMap.get(change.item);
          const viewIndex = this._viewContainerRef.indexOf(view);
          this._viewContainerRef.remove(viewIndex);
          this._viewMap.delete(change.item);
        });
        // Todo: Implemenet sort change.
      }
    }
  }

  private _addItem(item: any, index: number) {
    const context = new PfTestDirectiveContext(item, index);
    const view = this._viewContainerRef.createEmbeddedView(this.templateRef, context); // , index
    this._viewMap.set(item, view);
  }

  /*
  private _create(model: UDFModel, index: number) {
    const componentType: string = model.assignedComponent;
    if (componentType) {
      console.log(`DynamicComponentDirective: Using tpl "${componentType}" for model ${model.toString()}`);
    }
    this._loader.createComponentFactory(componentType)
      .then( factory => {

         // elInjector
         // content // Array of nodes

        const compRef = this._viewContainerRef.createComponent(factory); // this._viewContainerRef.length
        const nodes = compRef.hostView['rootNodes'] || [];
        const context = new PfTestDirectiveContext(nodes, index);
        const view = this._viewContainerRef.createEmbeddedView(this.templateRef, context); // , index

        // const compRef =  this.__viewContainerRefRef.createComponent( componentFactory, this.__viewContainerRefRef.length, elInjector,
        // this.ngComponentOutletContent);
        // this.compRefs.push(compRef);

        this._viewMap.set(model, view);
      });
  }
  */
}


export class PfTestDirectiveContext<T> {
  constructor(
    public $implicit: UDFModel,
    public index: number
  ) {}
   get first(): boolean { return this.index === 0; }
   get last(): boolean { return this.index === (this.$implicit.parent ? this.$implicit.parent.size - 1 : 0); }
   get even(): boolean { return this.index % 2 === 0; }
   get odd(): boolean { return !this.even; }
}
