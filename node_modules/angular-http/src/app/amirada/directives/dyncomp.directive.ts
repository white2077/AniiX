import {
  Directive,
  OnChanges,
  OnDestroy,
  Input,
  ComponentRef,
  ViewContainerRef,
  ComponentFactoryResolver,
} from '@angular/core';

import { UDFModel } from '../models/udf.model';

import {
  PF_ENTRY_COMPONENTS,
  BaseComponent,
  EmptyComponent,
  CompoundComponent,
  RecordComponent,
  CellComponent,
  ValueComponent,
  DownloadsComponent,
  TabsComponent,
  GraphicDataComponent,
  MaskComponent,
  DetailComponent,
  MaskCtrlComponent,
  TabComponent,
  ListComponent
} from '../../amirada';


const typeMap = {
  'base' : BaseComponent,
  'empty' : EmptyComponent,
  'compound' : CompoundComponent,
  'record' : RecordComponent,
  'cell' : CellComponent,
  'value' : ValueComponent,
  'downloads' : DownloadsComponent,
  'detail' : DetailComponent,
  'graphic-data' : GraphicDataComponent,
  'mask' : MaskComponent,
  'mask-ctrl' : MaskCtrlComponent,
  'tabs' : TabsComponent,
  'tab' : TabComponent,
  'list' : ListComponent
}


// import { DynCompLoaderService } from '../dyncomp.service';


@Directive({selector: '[pfDynComp]'})
export class DynCompDirective implements OnChanges, OnDestroy {

  private _model: UDFModel;
  private _compRefs: ComponentRef<any>[] = [];
  private _typeMap: Object = typeMap; // {};

  constructor(
    private _vcRef: ViewContainerRef,
    private _resolver: ComponentFactoryResolver,
  ) {
    /* unfortunately this does not work in production mode as class names get converted,
    but at leas this can be used to output typeMap to console for copy paste.
    Note: Uncomment las commetn for outout to console */
    const arr = [];
    PF_ENTRY_COMPONENTS.forEach(comp => {
      // Loos the ending 'composition'
      let compKey = comp.name.replace(/component/i, '');
      // Convert camelcased to dashed
      compKey =  compKey.replace(/([a-z])([A-Z])/g, '$1-$2').toLowerCase();
      // this._typeMap[compKey] = comp;
      arr.push(`'${compKey}' : ${comp.name}`);
    });
    // Uncomment for outout to console
    // console.log(arr.join(',\n'));
  }

  @Input() set pfDynComp(model: UDFModel) {
    this._model = model;
  }

  ngOnChanges() {
    this._cleanUp();
    if (!this._model) return;
    this.add(this._model);
  }

  public ngOnDestroy() {
    this._cleanUp();
  }

  public add(model: UDFModel) {

    if (model instanceof Array) {

      model.forEach(item => {
        this.add(item);
      });
      return;

    } else if (!(model instanceof UDFModel) || !model) {
      console.warn('Not an UDFModel.');
      return;
      // throw new Error('Not an UDFModel.');
    }

    this.create(model);
  }

  private _cleanUp() {
    while (this._compRefs.length) {
      this._compRefs.shift().destroy();
    }
  }

  // Without DyncompLoaderService.
  create(model) {

    const compKey = model.assignedComponent;
    /*
    if (model.level !== compKey)
      console.log(`DynCompDirective: Using tpl "${compKey}" for model ${model.toString()}`);
    */
    const comp = this._typeMap[compKey];
    if (!comp) {
      console.warn(`DynCompDirective: No comonent  "${compKey}" found in typeMap.`);
    } else {
      const factory = this._resolver.resolveComponentFactory(comp);
      const compRef = this._vcRef.createComponent(factory);
      (<any>compRef).instance.model = model;

      this._compRefs.push(compRef);
    }
  }

}

