/**
 * @file
 * ObservableModel provides an object with a observable stream for each property and the posibility
 * to be synced with other observable models of this kind.
 *
 * The Idea behind this is, that models - in this case the UDFModels context - can be synced so i.e. if
 * the mask model context changes (cat, psg, psh) the list model context will change correspondingly.
 */

import {NgZone} from '@angular/core';
import {BehaviorSubject} from 'rxjs/BehaviorSubject';
import {Observable} from 'rxjs/Observable';
import { EventEmitter } from '@angular/core';
import { PfDataService } from '../data.service';

export interface IChage {
  model: ObservableModel<any>;
  prop: string;
  old: any;
  new: any;
}

export interface IChageEvent {
  [name: string]: IChage;
}

export class ObservableModel<T> {

  /**
   * Private variables placeholders.
   * Will be replaced with getter functions.
   */

  private _data;
  private _cache;
  private _subjects;
  private _bindings;
  private _changes: any;
  private _props: any;

  public change: EventEmitter<IChageEvent>;

  constructor(obj?: any, asProxy?: boolean) {

    const __private__: any = {
      _data: asProxy ? obj : {},
      _cache: {},
      _subjects: {},
      _bindings: {},
      _changes: {},
      change: new EventEmitter()
    };

    // We leave enumerable, writable and configurable default false.
    for (const prop in __private__) {
      Object.defineProperty(this, prop, {
        get: () => { return __private__[prop]; }
      });
    }

    Object.defineProperty(this, 'updateData', {
      value: (arg) => {
        for (const foo in arg) {
          this._data[foo] = arg[foo];
        }
      }
    });

    Object.defineProperty(this, '_props', {
      get: () => {
        const result: any = {};
        for (const key in this) {
          const desc = Object.getOwnPropertyDescriptor(this, key);
          if (desc && desc.enumerable && desc.configurable) {
            result[key] = this[key];
          }
        }
        return result;
      }
    });

    if (obj) this._parseData(obj);

  }

  protected _parseData(data: any) {
    if (typeof data !== 'object') return;
    if (data instanceof ObservableModel)
      data = data._props;
    for (const prop in data) {
      this.addProperty( prop, data[prop] );
    }
  }

  public updateData(obj) {
    // Todo: Assigne values from obj
  }



  //
  /**
   * Until we geht Proxy to catch a new property being written we need this.
   * @param prop
   * @param value
   */
  public setProperty(prop, value): void {
    if (!this._subjects[prop]) {
      // Adding property will set property too
      this.addProperty(prop, value);
    } else {
      // Just set property
      this[prop] = value;
    }
  }

  /**
   * Will define a property getter/setter with default value.
   * For each property we set up a behaviorSubject and an observable of which the
   * observable/stream will be updated when setter is triggered.
   * Note: This Model only detects changes on first level assignment.
   * @param prop
   * @param value
   */
  public addProperty(prop: string, value?: any ): Observable<any> {

    /*
     const desc = Object.getOwnPropertyDescriptor(data, prop);
     if (desc && desc.enumerable && desc.configurable && !desc.get)
     */

    let subject, stream$ = this['_subjects'][prop];

    // If we have it, you gor it.
    if (stream$) return stream$;

    subject = new BehaviorSubject<any>(value);
    stream$ = subject.asObservable();

    Object.defineProperty(this, prop, {
      get: () => {
        const val = this._data[prop];
        /**
         * Todo: Idea behind this is that an object or array property can be fetched
         * and be modified, without reassigning the property.
         * I wanna make this work: obj.someArrayProp.push('foo');
         */
        /*
         // This makes trouble for the moment. Must be zone.runOutsideAngular.
         myTimeout(() => {this[prop] = val;});
         */
        return val;
      },
      set: (val) => {
        let bkp, old;

        old = this._data[prop];

        if (['string', 'boolean', 'number', 'undefined'].indexOf(typeof val) === -1) {
          // I know this is a little it's cheesy, but works fine if the value is not an extensive object
          // which should not be the case for a sub object/array of UDFModel context.
          try {
            bkp = JSON.stringify(val);
          } catch (err) {
            // will never be detected as as changed.
            bkp = false;
          }
        }

        if (this._cache[prop]) {
          if (bkp === this._cache[prop]) return;
        } else if (this._data[prop] === val) {
          return;
        }

        if (bkp) this._cache[prop] = bkp;
        const data = this._data;
        data[prop] = val;
        this._publishChange(prop, old, val, subject);

      },
      enumerable: true,
      configurable: true
    });


    // this._data[prop] = value;
    this._subjects[prop] = stream$;
    this[prop] = value;
  /*
    if (value !== void 0)
      this._publishChange(prop, void 0, value, subject);
*/
    return stream$;
  }


  private _publishChange(prop, old, val, subject) {
    subject.next(val);
    const bindings = this._bindings[prop];

    if (bindings) {
      for (const inst of bindings){
        if (typeof inst === 'function') {
          inst(val);
        } else {
          // Use setPropery if exists.
          (inst as ObservableModel<any>).setProperty
            ? inst.setProperty(prop, val)
            : inst[prop] = val;
        }
      }
    }

    // Ich prop has changed before get original old value
    if (this._changes[prop])
      old = this._changes[prop].old;

    this._changes[prop] = {
      model: this,
      prop: prop,
      old: old,
      new: val
    };
    // In order to publish the change event only once when a set of
    // properties have changed we use an immediate timeout function.
    const emit_fn = () => {
      // Remove ref to timeout so next change will be bublished too.
      delete this._cache.onChangeTimeout;

      // Add all occurred changes to event data.
      const changes: IChageEvent = {};
      // Shift over ...
      for (const key in this._changes)
        changes[key] = this._changes[key];
      // ... and delete.
      for (const key in this._changes)
        delete this._changes[key];

     // Reenter angular zone
      PfDataService.singleton.ngZone.run(() => {
        this.change.emit(changes);
      });
    };


    if (!this._cache.onChangeTimeout) {
      // We have to run this outside angular zone monkey patch change detection.
      PfDataService.singleton.ngZone.runOutsideAngular(() => {
        this._cache.onChangeTimeout = setTimeout(emit_fn, 0);
      });
    }



  }


  /**
   * Accepts name of property to be obproperty.
   * In order to subscribe to served.
   * Returns the stream for defined a yet unknown property we add
   * the missing property with unknown type and no default value.
   * @param prop - The property name to subscribe to.
   * @return {any}
   */
  public getObservable(prop: string): Observable<any>  {
    if (! this['_subjects'][prop])
      this.addProperty(prop);
    return this['_subjects'][prop];
  }

  public bind(propOrArrOrObj: any, target: (value: any) => void | any, scope?: any) {

    let prop = propOrArrOrObj;

    if (prop instanceof ObservableModel) {
      const obj = prop['_props'];
      for (const key in prop) {
        // debugger;
        const desc = Object.getOwnPropertyDescriptor(prop, key);
        if (desc && desc.enumerable && desc.configurable) {
         // console.log('observableModel bind ', prop, key , 'to', this);
          (prop as ObservableModel<any>).bind(key, (target as any));
        }
      }
      return;

    } else if (prop instanceof Array) {
      for (let i = 0; i < prop.length; i++)
        this.bind(prop[i], target);
      return;

    } else if (prop instanceof Object) {
      for (const key in prop)
        this.bind(prop[key], target);
      return;

    } else if (typeof prop === 'string') {
      // ok
      prop = prop as String;

    } else {
      console.warn('Wrong parameter for ObservableModel#bind', prop);
      return;

    }

    if (!this['_subjects'][prop]) {
      // Use target default value if possible.
      const value = (typeof target[prop] !== 'function') ? target[prop] : void 0;
      if (target instanceof ObservableModel){
        (target as ObservableModel<any>).addProperty(prop, value);
      }
      this.addProperty(prop, value);
    }

    // Bind callback to scope if needed.
    if (scope && typeof target === 'function') target = target.bind(scope);

    // Create props bindings list if missing.
    if (!this._bindings[prop]) this._bindings[prop] = [];

    // Just make sure we do not add more the one.
    if (! this._bindings[prop].some(item => { return item === target; })) {
      // Add target inst to props bindings list.
      this._bindings[prop].push(target);
    }
  }

  public unbind(prop: string, target: (value: any) => void | object) {
    if (!this._bindings[prop]) return;
    if (!this._bindings[prop].some(item => { return item === target; })) {
      // Remove target inst from props bindings list.
      this._bindings[prop].splice(this._bindings[prop].indexOf(target));
      // Remove  props bindings if empty.
      if (this._bindings[prop].length === 0)
        delete this._bindings[prop];
    }
  }

  public destroy() {
    console.warn('Todo: obs.model#destroy!!');
    // this.change
    delete this._data;
    delete this._subjects;
    delete this._bindings;
  }

  /**
   *
   * @param keepReference
   * @return {{}&U}
   */
  public toObject<T>(keepReference?: boolean): T {
    return  keepReference ? this._data : Object.assign({}, this._data);
  }

}
