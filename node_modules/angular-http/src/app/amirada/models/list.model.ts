import { UDFModel, UDFData, UDFLink, UDFHeader } from './udf.model';
import { PFCONST } from '../consts';
import { PfDataService } from '../data.service';
import { IChageEvent } from './obs.model';

export class ListModel extends UDFModel {

  constructor(data?: UDFData, link?: UDFLink, options?: any) {
    super(data, link, options);

    if (!this.parent) {
      this.context.change.subscribe(changes => {
        let initial = true;
        /*
        for (const key in changes) {
          if (changes[key].old !== void 0){
            initial = false;
            break;
          }
        }
        if (initial) {
          console.warn(`Todo: initial changes from undefined to what ever triggering _onContextChange. Initial Change should be published?`)
          return;
        }
        */
        this._onContextChange(changes);
      });
    }

  }

  private _onContextChange(changes: IChageEvent) {

    // Make sure whe execute in root scope.
    if (this !== this.root)
      return (this.root as ListModel)._onContextChange(changes);

    // Check if currently loading.
    if (this._cache.loading) return;

    this._cache.loading = true;

    if (changes.psg || changes.psh || changes.sort_by || changes.sort_order) { /* The complete list hast changed */
      const contextData = this.context.toObject(true);
      contextData.from = 0;
    }

    const subscription = PfDataService.singleton.getData(this.context)
      .subscribe(data => {
        subscription.unsubscribe();

        if (changes.psg || changes.psh || changes.sort_by || changes.sort_order) { /* The complete list hast changed */
          // Reset model
          this.destroy();
          // Parse new data
          this.parseData(data);

        } else if (changes.from) { /* Just som new children to add */
          if (data.items) {
            for (let i = 0; i < data.items.length; i++) {
              const childData = data.items[i];
              // Append child
              this.addChild(childData);
            }
            this._data['from'] = this.context.from;
          } else {
            debugger;
          }
        }

        this._cache.loading = false;
      });

  }

  nextSet(amount?: number) {
    // Make sure to we are in root scope.
    if (this.root !== this) return (this.root as ListModel).nextSet(amount);
    // Ignore we have not been loaded as set
    if (!this.context.from === void 0) return;
    // Check if all loaded
    if (Number(this.context.from) + Number(this.context.count)  >= this._data.count) return;
    // If this is the case it means we are still loading.
    if (this.context.from !== this._data['from'])  return;
    // We just load 'from' last 'to'
    this.context.from = Number(this.context.from) + Number(this.context.count);
    // Set count if amount is passsed as argument.
    if (amount) this.context.count = amount || 1;
  }

};
