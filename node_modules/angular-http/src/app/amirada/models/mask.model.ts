import { UDFModel, UDFData, UDFLink, UDFHeader } from './udf.model';
import { PFCONST } from '../consts';
import { PfDataService } from '../data.service';
import { IChageEvent } from './obs.model';


/**
 * Activating/deactivating a node leads to automatic update state of model tree.
 * State changes are basically just the number of hits expected for node activation.
 */

export class MaskModel extends UDFModel {

  constructor(data?: UDFData, link?: UDFLink, options?: any) {
    super(data, link, options);

    if (!this.parent) {
      this.context.change.subscribe(changes => {
        this._onContextChange(changes);
      });
    }

  }

  /**
   * Retunts the input type checkbox or radio for attribute binding.
   * @return {string|string}
   */
  public get uiType(): string {
    const radioAND = ((this.attr.SGO & PFCONST.sgo_RadioAND)	=== PFCONST.sgo_RadioAND);
    return radioAND ? 'radio' : 'checkbox';
  }

  /**
   * Gives option type AND (psg) or OR (psh).
   * As 'checkOR' is the only OR option rest (comboAND, checkAND, radioAND) returns AND
   * @return {string|string}
   */
  public get opType() {
    const checkOR 	= ((this.attr.SGO & PFCONST.sgo_CheckOR)	=== PFCONST.sgo_CheckOR); // PSH, select multible
    return checkOR  ? 'OR' : 'AND';
  }

  /**
   * Just for clarity of relation.
   * @return {string|string}
   */
  public get psType() {
    return this.opType === 'OR' ? 'psh' : 'psg';
  }

  /**
   * Check in context if psg/psh is set for this item.
   * @return {boolean}
   */
  public get active(): boolean {
    const group = this.getAncestor('record').name;

    if (!this.context[this.psType] || !this.context[this.psType][group])
      return false;

    return (this.context[this.psType][group].indexOf(this.value) !== -1);
  }

  /**
   * Binding to this property leads to automatic model updates.
   * Will set/unset psg/psh for this item.
   * In case of radio group and activation the sibling models are set inactive.
   * maskUpdate is triggered and all nodes in model tree are getting updated.
   * @param active
   */
  public set active(active: boolean) {

    const group = this.getAncestor('record').name;
    const psObj = this.context[this.psType] || {};

    if (active) {

      if (! psObj[group])
        psObj[group] = [];

      psObj[group].push(this.value);

    } else {

      // If this was active psObject must exists with with group.
      // Remove from context ps group object.
      const index = psObj[group].indexOf(this.value);
      psObj[group].splice(index, 1);

      // Remove group if empty.
      if (psObj[group].length === 0)
        delete psObj[group];

    }

    // As the change in the subobject of context has no effect on data binding we need to trigger it
    // by just erassigning to make change known.
    this.context.setProperty(this.psType, psObj);

    // Note: Radio group is not handeled by DOM but by model itself.
    if (active && this.uiType === 'radio') {
      // Get all active sibblings ...
      const siblings = (this.getAncestor('compound')
        .filter( item => { return item.active && item !== this; }, true ) as Array<MaskModel>);
      // ... and set them inactive.
      for (const sib of siblings) sib.active = false;
    }
  }

  /**
   * Number of hits expected for node activation.
   * @return {Number}
   */
  public get numHits(): number {
    return Number(this.attr.NUM);
  }

  /**
   * Disable if no filter results possible.
   * @return {boolean}
   */
  public get disabled(): boolean {
    // Must return null to make angular remove attribute.
    return (this.numHits > 0) ? null : true;
  }


  private _onContextChange(changes: IChageEvent) {

    // Make sure we execute in root scope.
    if (this !== this.root)
      return (this.root as MaskModel)._onContextChange(changes);

    // No need to block GUI as changes made while loading
    // will be undone when update request is applied.
    if (this._cache.loading) return;

    this._cache.loading = true;

    const subscription = PfDataService.singleton.getData(this.context)
      .subscribe(data => {
        subscription.unsubscribe();
        this.updateData(data);
        this._cache.loading = false;
      });

  }

};
